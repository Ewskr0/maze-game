### Pour la première partie, tous les test sont visible ####

#include <iostream>
#include <cassert>
#include <tuple>
#include <set>

#1

// Points
point2d p0{3, 4}; // Ctor
auto p0c{p0}; // CCtor
auto p0ca = p0; //Copy-Ctor
if (p0 != p0c || p0 != p0ca || !(p0 == p0c)) {
  std::cout << "Copy constructed points did not compare equal to the original point\n";
}

// Offsets
offset2d o0{-3, 44}; // Ctor
auto o0c{o0}; // CCtor
auto o0ca = o0; //Copy-Ctor
if (o0 != o0c || o0 != o0ca || !(o0 == o0c)) {
  std::cout << "Copy constructed offsets did not compare equal to the original offsets\n";
}
// Arithmetic
if (p0 + o0 != point2d{0, 48}) {
  std::cout << "Addition of point and offset failed\n";
  return false;
}

point2d p1{13, 88};
p0 += (p1 - p0);
if (p0 != p1) {
  std::cout << "operator+=(const offset2d& o) of point2d failed\n";
}

#2

std::set<point2d> set_points;
set_points.insert({2,3});
set_points.insert({2,3});
if (set_points.size() != 1) {
  std::cout << "Identical points got added twice\n";
}

set_points.insert({44,22});
if ( not set_points.count({2,3})){
  std::cout << "Point that should exist was not found\n";
}

if (set_points.count({3,4})){
  std::cout << "Point that should not exist was found\n";
}

#### Deuxième partie #####

#include <vector>
#include <algorithm>
#include <iostream>
#include <cassert>
#include <tuple>
#include <set>
#include <utility>
#include <memory>

#1
bool test_ctor()
{
  maze_entrance i;
  maze_exit e;
  path p;
  wall w;
  small_trap s;
  large_trap l;
  hidden_trap h;

  if (i.to_char() != 'I') {
    std::cout << "Got wrong char for entrance\n";
    return false;
  }
  if (e.to_char() != 'O') {
    std::cout << "Got wrong char for exit\n";
    return false;
  }
  if (p.to_char() != ' ') {
    std::cout << "Got wrong char for path\n";
    return false;
  }
  if (w.to_char() != 'w') {
    std::cout << "Got wrong char for wall\n";
    return false;
  }
  if (s.to_char() != 't') {
    std::cout << "Got wrong char for small trap\n";
    return false;
  }
  if (l.to_char() != 'T') {
    std::cout << "Got wrong char for large trap\n";
    return false;
  }
  if (h.to_char() != ' ') {
    std::cout << "Got wrong char for non-triggered hidden trap\n";
    return false;
  }
  return true;
}

#2
bool test_effects()
{
  maze_entrance i;
  if ((i.effect({0,0}, false) !=  field_effect{ field_state::ENTRANCE, 0})
      || (i.effect({1,1}, false) !=  field_effect{ field_state::NONE, 0}))
  {
    std::cout << "Error in \n";
    return false;
  }
  maze_exit e;
  if ((e.effect({0,0}, false) !=  field_effect{ field_state::EXIT, 0})
      || (e.effect({1,1}, false) !=  field_effect{ field_state::NONE, 0}))
  {
    std::cout << "Error in exit\n";
    return false;
  }
  path p;
  if ((p.effect({0,0}, false) !=  field_effect{ field_state::FREE, 0})
      || (p.effect({1,1}, false) !=  field_effect{ field_state::NONE, 0}))
  {
    std::cout << "Error in path\n";
    return false;
  }
   wall w;
  if ((w.effect({0,0}, false) !=  field_effect{ field_state::BLOCKED, 0})
      || (w.effect({1,1}, false) !=  field_effect{ field_state::NONE, 0}))
  {
    std::cout << "Error in wall\n";
    return false;
  }
  small_trap s;
  if ((s.effect({0,0}, false) !=  field_effect{ field_state::DEADLY, 0})
      || (s.effect({1,1}, false) !=  field_effect{ field_state::NONE, 0}))
  {
    std::cout << "Error in small trap\n";
    return false;
  }
  large_trap l;
  if ((l.effect({0,0}, false).state !=  field_state::DAMAGING)
      || (l.effect({1,1}, false).state !=  field_state::DAMAGING)
      || (l.effect({2,2}, false).state !=  field_state::NONE))
  {
    std::cout << "Error in large trap\n";
    return false;
  }
  return true;
}

#3
// This test is not exhaustive.
// You can produce code that succeeds here, but is "useless"
// in the actual program
bool test_effect_acc()
{
  maze_entrance i;
  maze_exit e;
  path p;
  wall w;
  small_trap s;
  large_trap l;
  hidden_trap h;

  {
    auto eff = i.effect({0,0}, false);
    eff += s.effect({0,0}, false);
    if (eff.state !=  field_state::DEADLY){
      std::cout << "Expected DEAD when encountering small trap\n";
      return false;
    }
    eff += w.effect({0,0}, false);
    if (eff.state !=  field_state::BLOCKED){
      std::cout << "Expected BLOCKED when encountering a wall\n";
      return false;
    }
  }

  {
    auto eff = p.effect({0,0}, false);
    if (eff !=  field_effect{ field_state::FREE, 0}){
      std::cout << "Wrong effects after encountering PATH\n";
      return false;
    }
    eff += s.effect({0,1}, false);
    if (eff !=  field_effect{ field_state::FREE, 0}){
      std::cout << "Wrong effects after encountering PATH "
                   "then avoiding a trap\n";
      return false;
    }
    eff += l.effect({1,0}, false);
    if ((eff.state !=  field_state::DAMAGING)
        || (eff.damage < 5)){
      std::cout << "Expected at least 5 damage when encountering large trap\n";
      return false;
    }
  }
  return true;
}

#4
bool test_from_char()
{
  if ( to_field('I')->to_char() != 'I')
  {
    std::cout << " to_field failed for \"I\"\n";
    return false;
  }
  if ( to_field('O')->to_char() != 'O')
    {
    std::cout << " to_field failed for \"O\"\n";
    return false;
  }
  if ( to_field(' ')->to_char() != ' ')
    {
    std::cout << " to_field failed for \" \"\n";
    return false;
  }
  if ( to_field('w')->to_char() != 'w')
    {
    std::cout << " to_field failed for \"w\"\n";
    return false;
  }
  if ( to_field('t')->to_char() != 't')
    {
    std::cout << " to_field failed for \"t\"\n";
    return false;
  }
  if ( to_field('T')->to_char() != 'T')
    {
    std::cout << " to_field failed for \"T\"\n";
    return false;
  }
  auto f_ptr =  to_field('H');
  if (f_ptr->to_char() != ' ')
    {
    std::cout << " to_field failed for \"H\" if hidden\n";
    return false;
  }
  f_ptr->effect({0, 0}, false);
  if (f_ptr->to_char() != 'T')
  {
    std::cout << " to_field failed for \"H\" if discovered\n";
    return false;
  }
  return true;
}


#### Troisième partie #####

#include <string>
#include <vector>
#include <algorithm>
#include <iostream>
#include <cassert>
#include <tuple>
#include <set>
#include <vector>
#include <cmath>

bool test_box()
{
  {
    box_iterator b0{1, 3, 2, 8};
    box_iterator b1{1, 3, 2, 8};
    if (b0 != b1) {
      std::cout << "Iterators should be equal when created from the same args\n";
      return false;
    }
    ++b1;
    if (b0 == b1) {
      std::cout << "Iterator should not be equal after incrementation\n";
      return false;
    }
  }

  {
    coord x_beg = 0, x_end = 4, y_beg = 2, y_end = 7;
    std::set<point2d> box_points;
    box_iterator b{x_beg, x_end, y_beg, y_end};
    b.reset();
    for (coord i = 0; i < (x_end-x_beg)*(y_end-y_beg); ++i) {
      box_points.insert(*b);
      ++b;
    }
    // Test if all points have been visited
    for (coord x = x_beg; x < x_end; ++x)
      for (coord y = y_beg; y < y_end; ++y)
        if (not box_points.count({x,y})){
          std::cout << "box_iterator did not visit (" << x << ", " << y
                    << ") which is inside the box x_beg= " << x_beg
                    << ", x_end =" << x_end << ", y_beg =" << y_beg
                    << ", y_end =" << y_end << "\n";
          return false;
        }
  }
  return true;
}


##### Quatrième partie #####

#include <string>
#include <vector>
#include <algorithm>
#include <vector>
#include <iostream>
#include <cassert>
#include <tuple>
#include <set>


bool test_storage()
{
  // In your actual program, the storage will hold shared_ptrs to fields.
  // However, as this is just a template argument,
  // we can test it any type, like for instance ints
  try {
    storage<int> test_s(7);
    std::cout << "Storage of size seven cannot exist, as the "
                 "underlying matrix cannot be square!\n";
    return false;
  } catch (const std::runtime_error&) {
    // Expected error
  } catch(...){
    std::cout << "Expected runtime_error for out-of-bounds access\n";
    return false;
  }

  storage<int> test_s(0);
  test_s.resize(9);

  int counter = 0;
  for (coord i = 0; i < 3; ++i)
    for (coord j = 0; j < 3; ++j)
      test_s({i,j}) = ++counter;

  for (coord i = 2; i >= 0; --i)
    for (coord j = 2; j >= 0; --j)
      if (test_s({i,j}) != counter--){
        std::cout << "Input - Output error for storage\n";
        return false;
      }

  try {
    auto e = test_s({3,4});
    auto f = test_s({-1,-1});
    std::cout << "Can access non-existing elements with values " << e << " and " << f << std::endl;
    return false;
  } catch (const std::runtime_error&) {
    // Expected error
  } catch(...){
    std::cout << "Expected runtime_error for out-of-bounds access\n";
    return false;
  }

  return true;
}
